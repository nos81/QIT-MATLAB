function [dH, A, label] = rotating_frame(H, D, varargin)
% ROTATING_FRAME  Hermitian operator in a rotating frame.
%  [dH, A, label] = rotating_frame(H, D)
%
%  Returns a representation of the hermitian operator D in a rotating
%  frame generated by the hermitian operator H.
%
%  We assume H has been made dimensionless by dividing with \hbar and
%  multiplying with the time unit.
%
%  Starting with the spectral decomposition H = \sum_k w_k P_k,
%  where w_k are the eigen(angular)frequencies of H and P_k the corresponding
%  hermitian projectors, in the rotating frame D is given by
%
%    D'(t) = exp(i*H*t) * D * exp(-i*H*t) = \sum_{ab} exp(i*(w_a-w_b)*t) P_a*D*P_b.
%
%  Grouping together all the terms rotating at the same frequency v, we obtain
%
%    D(v)  = \sum_{ab, such that w_b-w_a = v} P_a*D*P_b
%    D'(t) = \sum_v exp(-i*v*t) D(v)
%
%  Since D is hermitian, we have D(-v) = D(v)'. Hence it suffices
%  to return the terms corresponding to nonnegative v:s.
%
%  If D is a cell vector of hermitian operators, they are decomposed separately.
%  Returns dH, a vector of the sorted unique nonnegative differences between
%  eigenvalues of H, and A, a cell array of the corresponding summed projections of D.
%  size(A) == [length(dH), length(D)]
%  label is a cell vector containing text labels that describe the content of the summed projectors.

% Ville Bergholm 2009-2017


global qit;

opt = struct(varargin{:});
% TODO justify the default numerical tolerances
if ~isfield(opt, 'tol_dH')
    % tolerance for grouping transition frequencies
    opt.tol_dH = 1e6 * qit.tol;
end
if ~isfield(opt, 'tol_norm')
    % tolerance for rotating term norms
    opt.tol_norm = qit.tol;
end


[E, P] = spectral_decomposition(full(H), true, opt.tol_dH);
m = length(E); % unique eigenvalues

% compute all the eigenvalue differences
temp = E * ones(1, m);
deltaE = temp -temp.';  % deltaE(i,j) = E(i)-E(j)
% energy difference matrix is antisymmetric, so we really only need
% the nonnegative lower triangle

% we want the energy differences sorted so they can be grouped later on
[deltaE, ind] = sort(deltaE(:));

% index of first lower triangle element (incl. the diagonal)
s = m*(m-1)/2 + 1;
%assert(ind(s), 1)
deltaE = deltaE(s:end);
ind = ind(s:end);


if ~iscell(D)
  D = {D}; % D needs to be a cell array, even if it has just one element
end
n_D = length(D); % number of bath coupling ops

% projected slices of D
A = cell(0, n_D);

s = 0; % index of the currently built jump op
current_dH = Inf;

% Combine degenerate deltaE values, build the D(v) slices.
for k = 1:length(deltaE)
  diff = abs(deltaE(k) -current_dH);
  if diff > opt.tol_dH
    % new omega value, new jump op
    % otherwise just extend current op
    s = s+1;
    dH(s,1) = deltaE(k);
    current_dH = dH(s,1);
    A(s,:) = num2cell(zeros(1, n_D));
    label{s,1} = '';
  end
  % given k, find corresponding row and column in the deltaE matrix
  [r, c] = ind2sub([m, m], ind(k));
  % add projection of D corresponding to the index k to the jump op number s
  for op=1:n_D
      A{s, op} = A{s, op} +P{c} * D{op} * P{r};
  end
  label{s} = sprintf('%s (%d,%d)', label{s}, c, r);
end

% eliminate zero As and corresponding dHs
temp = zeros(size(A));
for op=1:n_D
    for k=1:length(dH)
        temp(k, op) = norm(A{k, op}) <= opt.tol_norm;
    end
end
% rows in which every A vanishes
temp = all(temp, 2);
% remove them
A(temp,:) = [];
dH(temp) = [];
label(temp) = [];
